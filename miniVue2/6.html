<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>依赖收集和视图同步更新原理 | Happyblog</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="基于 vuepress 的简易博客平台">
    
    <link rel="preload" href="/vuepress-blog/assets/css/0.styles.631b7830.css" as="style"><link rel="preload" href="/vuepress-blog/assets/js/app.f8677ea4.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/2.32f56e5c.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/1.a930a345.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/52.1650a6e6.js" as="script"><link rel="prefetch" href="/vuepress-blog/assets/js/10.ab76fc9b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/11.8f72b06d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/12.428f6f98.js"><link rel="prefetch" href="/vuepress-blog/assets/js/13.eb47b2b6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/14.7257e695.js"><link rel="prefetch" href="/vuepress-blog/assets/js/15.bd1b03c3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/16.7a561afc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/17.cd516f79.js"><link rel="prefetch" href="/vuepress-blog/assets/js/18.42e9f2b1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/19.4958156f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/20.cd1f9a1c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/21.e4fea2d1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/22.0919633c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/23.331c698f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/24.5874fb5a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/25.e56a5813.js"><link rel="prefetch" href="/vuepress-blog/assets/js/26.7e912fb0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/27.aa11be6f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/28.b8505e46.js"><link rel="prefetch" href="/vuepress-blog/assets/js/29.155d9866.js"><link rel="prefetch" href="/vuepress-blog/assets/js/3.d7d8640a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/30.80297b92.js"><link rel="prefetch" href="/vuepress-blog/assets/js/31.977ccbdd.js"><link rel="prefetch" href="/vuepress-blog/assets/js/32.767609f9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/33.44891ea8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/34.f516ab0b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/35.151a5daf.js"><link rel="prefetch" href="/vuepress-blog/assets/js/36.ece446f9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/37.37735106.js"><link rel="prefetch" href="/vuepress-blog/assets/js/38.45a9e8b8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/39.0fcd7dcc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/4.ecf7f9e8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/40.621682ab.js"><link rel="prefetch" href="/vuepress-blog/assets/js/41.d03d4354.js"><link rel="prefetch" href="/vuepress-blog/assets/js/42.edf41024.js"><link rel="prefetch" href="/vuepress-blog/assets/js/43.8cd60945.js"><link rel="prefetch" href="/vuepress-blog/assets/js/44.de2cd4e9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/45.4fb41246.js"><link rel="prefetch" href="/vuepress-blog/assets/js/46.b26d762d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/47.3bb572d2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/48.dc6af168.js"><link rel="prefetch" href="/vuepress-blog/assets/js/49.9511edba.js"><link rel="prefetch" href="/vuepress-blog/assets/js/5.8cea2090.js"><link rel="prefetch" href="/vuepress-blog/assets/js/50.2e05304d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/51.f72b0b54.js"><link rel="prefetch" href="/vuepress-blog/assets/js/53.36c638aa.js"><link rel="prefetch" href="/vuepress-blog/assets/js/54.5931bcf4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/55.f48c6b88.js"><link rel="prefetch" href="/vuepress-blog/assets/js/56.6d799974.js"><link rel="prefetch" href="/vuepress-blog/assets/js/57.0abda071.js"><link rel="prefetch" href="/vuepress-blog/assets/js/58.e4e2e95d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/59.fc9cc726.js"><link rel="prefetch" href="/vuepress-blog/assets/js/6.5b653d91.js"><link rel="prefetch" href="/vuepress-blog/assets/js/60.d0cdc48d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/61.e663cede.js"><link rel="prefetch" href="/vuepress-blog/assets/js/62.1b3ef15b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/63.b17e2bda.js"><link rel="prefetch" href="/vuepress-blog/assets/js/64.3b7bc255.js"><link rel="prefetch" href="/vuepress-blog/assets/js/65.bb24c420.js"><link rel="prefetch" href="/vuepress-blog/assets/js/7.fcec5877.js"><link rel="prefetch" href="/vuepress-blog/assets/js/vendors~docsearch.a0f89813.js">
    <link rel="stylesheet" href="/vuepress-blog/assets/css/0.styles.631b7830.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-blog/" class="home-link router-link-active"><!----> <span class="site-name">Happyblog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vuepress-blog/miniVue2/" class="nav-link router-link-active">
  mini-Vue2 文档
</a></div><div class="nav-item"><a href="/vuepress-blog/performance/" class="nav-link">
  性能优化
</a></div><div class="nav-item"><a href="/vuepress-blog/chat/" class="nav-link">
  前端杂谈
</a></div><div class="nav-item"><a href="https://github.com/Nwu23787/mini-Vue2" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vuepress-blog/miniVue2/" class="nav-link router-link-active">
  mini-Vue2 文档
</a></div><div class="nav-item"><a href="/vuepress-blog/performance/" class="nav-link">
  性能优化
</a></div><div class="nav-item"><a href="/vuepress-blog/chat/" class="nav-link">
  前端杂谈
</a></div><div class="nav-item"><a href="https://github.com/Nwu23787/mini-Vue2" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>mini-Vue2 文档</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-blog/miniVue2/1.html" class="sidebar-link">响应式数据的监听</a></li><li><a href="/vuepress-blog/miniVue2/2.html" class="sidebar-link">render 函数和 h 函数</a></li><li><a href="/vuepress-blog/miniVue2/3.html" class="sidebar-link">模版解析为 AST 语法树</a></li><li><a href="/vuepress-blog/miniVue2/4.html" class="sidebar-link">AST语法树转化为 render 函数</a></li><li><a href="/vuepress-blog/miniVue2/5.html" class="sidebar-link">虚拟DOM转化为真实DOM</a></li><li><a href="/vuepress-blog/miniVue2/6.html" aria-current="page" class="active sidebar-link">依赖收集和视图同步更新</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress-blog/miniVue2/6.html#_1、mvvm" class="sidebar-link">1、MVVM</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/miniVue2/6.html#_2、观察者模式" class="sidebar-link">2、观察者模式</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/miniVue2/6.html#_3、watcher" class="sidebar-link">3、Watcher</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/miniVue2/6.html#_4、dep" class="sidebar-link">4、Dep</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/miniVue2/6.html#_5、收集依赖" class="sidebar-link">5、收集依赖</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/miniVue2/6.html#_6、梳理执行流程" class="sidebar-link">6、梳理执行流程</a></li></ul></li><li><a href="/vuepress-blog/miniVue2/7.html" class="sidebar-link">$nextTick</a></li><li><a href="/vuepress-blog/miniVue2/8.html" class="sidebar-link">异步更新</a></li><li><a href="/vuepress-blog/miniVue2/9.html" class="sidebar-link">数组的依赖收集和更新</a></li><li><a href="/vuepress-blog/miniVue2/10.html" class="sidebar-link">computed 计算属性</a></li><li><a href="/vuepress-blog/miniVue2/11.html" class="sidebar-link">watch 侦听器</a></li><li><a href="/vuepress-blog/miniVue2/12.html" class="sidebar-link">mixin</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>mini-Vue-router3 文档</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>mini-Vuex3 文档</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="依赖收集和视图同步更新原理"><a href="#依赖收集和视图同步更新原理" class="header-anchor">#</a> 依赖收集和视图同步更新原理</h1> <p>之前已经讲解过 Vue2 中的属性劫持、虚拟 DOM 以及通过虚拟 DOM 生成真实 DOM 的过程，但是还没有实现响应式数据变化，视图同步更新的核心功能。因为我们虽然对数据做了劫持，可以监听到响应式数据发生的变化，也实现了根据模版生成 render 函数再获取到虚拟 DOM，最后转化为真实 DOM 挂载的这个流程。但是，这两个流程之间没有关联，我们希望的是，当响应式数据发生变化之后，相应的组件会自动执行<strong>模版-&gt;render-&gt;虚拟DOM-&gt;真实DOM</strong>的这一套渲染流程，从而更新视图。本文我们就来讲解这部分原理。文章源码项目地址：<a href="https://github.com/Nwu23787/mini-Vue2" target="_blank" rel="noopener noreferrer">Nwu23787/mini-Vue2: 手写 Vue2 核心源码 (github.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_1、mvvm"><a href="#_1、mvvm" class="header-anchor">#</a> 1、MVVM</h2> <p>Vue 是一个渐进式的，基于 MVVM 的 JavaScript 框架。所谓 MVVM 设计模式，主要是为了实现程序的解耦，程序解耦的好处就在于，我们可以在不同的部分中，关注不同的业务逻辑，也就是关注点的分离，而不是将各个部分杂糅在一起来写的。比如我们在 template 中，更加关注页面布局，而在 script 中，就更加关注数据的相关逻辑。</p> <p>所谓 MVVM，其实就是将系统结构分为了三个层次：</p> <ol><li><strong>Model（M）：数据层</strong>，负责数据的处理和存储，是我们实现业务逻辑的地方。也就是 Vue 中的 data 对象。</li> <li><strong>View（V）：视图层</strong>，负责将数据展示给用户。也就是 Vue 中的模版。</li> <li><strong>ViewModel（VM）</strong>：视图模型层，是数据层和视图层之间的桥梁。也就是 Vue 中的 Vue 实例。</li></ol> <p>MVVM 架构中，不允许 Model 层与 View 层直接进行交互，必须通过 ViewModel 来进行通信。ViewModel 其实就是类似于一个观察者，它可以观察到数据的变化，并且通知变化数据对应的视图进行更新；也可以观察到视图层发生的变化，从而通知相应的数据发生改变。</p> <p>Vue 其实就是一个 MVVM 的实现者，核心就是实现了数据劫持和DOM监听。</p> <h2 id="_2、观察者模式"><a href="#_2、观察者模式" class="header-anchor">#</a> 2、观察者模式</h2> <p>观察者模式是一种行为设计模式。其核心由两个对象组成：观察者和被观察者。当被观察者发生变化的时候，它会通知所有的观察者对象，观察者对象会对这种变化做出相应的反应。</p> <p>Vue 在实现响应式数据发生变化，视图同步更新时，就使用到了观察者模式。首先 Vue 定义了两个类，作为观察者和被观察者。第一个是 watcher，他其实就是定义了一个观察者，每个 watcher 实例上有一个 update 方法，执行 update 方法，可以更新对应的视图。第二个是 Dep，dep 其实就是一个被观察者，我们为每一个模版中用到的属性绑定一个 Dep 实例，dep 中维护着该属性对应的 watcher 队列，当属性发生变化的时候，遍历通知 dep 对应的所有 watcher。</p> <h2 id="_3、watcher"><a href="#_3、watcher" class="header-anchor">#</a> 3、Watcher</h2> <p>Watcher 中的关键部分就在于 update 这个方法，其实这个方法就是封装了渲染部分的代码逻辑。在前面我们已经说过，想要实现模版转化为真实 DOM，必须经过 render 函数将模版转化为虚拟 DOM，再经过 update 方法（本质上就是调用了 patch 方法）将虚拟 DOM 转化为真实 DOM 并挂载。所以，我们只要将 update 和 render 这两个方法，封装到 watcher 的 update 方法中，在每次数据发生变化的时候，调用这个 watcher 相应的 update 方法，就可以实现组件的重新渲染，从而更新视图。</p> <p>watcher 部分源码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Dep <span class="token keyword">from</span> <span class="token string">&quot;./dep&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
    <span class="token comment">// vm watcher 对应的组件的实例，fn 组件对应的渲染函数</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用 id 来区分不同组件的 watcher</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token operator">++</span>
        <span class="token comment">// 把渲染函数绑定watcher到实例上，调用getter即可重新渲染，更新视图</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>getter <span class="token operator">=</span> fn
        <span class="token comment">// 标记是否是一个渲染watcher</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>renderWatcher <span class="token operator">=</span> options
        <span class="token comment">// 收集 watcher 对应的 dep</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token comment">// 使用 set 保存 deps 中所有 dep 的id，便于去重操作</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>depsId <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 调用</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 渲染函数</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在渲染开始之前，把 watcher 挂载到全局，也就是 Dep 类上（静态属性）</span>
        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 渲染结束，把全局的 watcher 卸载</span>
        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 给 watch 添加 dep</span>
    <span class="token function">addDep</span><span class="token punctuation">(</span><span class="token parameter">dep</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 要判断这个 dep 是否已经被记录，防止重复记录</span>
        <span class="token keyword">let</span> id <span class="token operator">=</span> dep<span class="token punctuation">.</span>id
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>depsId<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// id 不存在与 depsId 中，则这个 dep 没有被 watcher 收集过</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>depsId<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
            <span class="token comment">// 让 dep 收集 watcher</span>
            dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 更新视图</span>
    <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> Watcher
</code></pre></div><p>每一个组件在挂载前，都会生成一个对应的 watcher：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将 el 对应的真实 dom 挂载到 vm 上，便于后面获取</span>
    vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> el

    <span class="token keyword">const</span> <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1. 调用 render 方法，获得虚拟 DOM</span>
        <span class="token keyword">let</span> vnode <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment">// 2. 根据虚拟 DOM，生成真实 DOM</span>
        vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span>
</code></pre></div><p>将组件对应的渲染逻辑封装成函数传递给 watcher，作为 watcher 的 update 方法。</p> <p>由此可以看出，Vue 视图的更新，是<strong>以组件为粒度的</strong>，组件中任何数据发生变化，都会导致整个组件的全部刷新。所以，我们在开发时一定要养成组件化的好习惯，组件化的好处不仅仅是复用，更重要的是还可以实现页面的<strong>局部刷新</strong>。</p> <h2 id="_4、dep"><a href="#_4、dep" class="header-anchor">#</a> 4、Dep</h2> <p>Dep 是被观察者，我们需要为模版中用到的每一个响应式数据都创建一个 dep 对象与之绑定。Dep 类的定义如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> id <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token operator">++</span>
        <span class="token comment">// 用于收集数据对应的 watcher</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 将 dep 传递给 watcher，进行去重</span>
    <span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// this.subs.push(Dep.target)</span>
        Dep<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">addDep</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 给 dep 收集对应的 watcher 依赖</span>
    <span class="token function">addSub</span><span class="token punctuation">(</span><span class="token parameter">watcher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 数据更新后，通知 watcher 更新</span>
    <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">watcher</span> <span class="token operator">=&gt;</span> watcher<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> Dep
</code></pre></div><p>其中 subs 用于收集属性所对应的依赖，也就是 watcher。当数据发生变化时，调用 dep 的 notify 方法，改方法会遍历 subs 中的所有 watcher，并执行每一个 watcher 所对应的 update 方法，更新视图。</p> <h2 id="_5、收集依赖"><a href="#_5、收集依赖" class="header-anchor">#</a> 5、收集依赖</h2> <p>所谓收集依赖，就是为 dep 收集其所对应的 watcher。这个过程是在组件初次渲染的过程中执行的。在组件初始化时，我们为每一个 data 中的属性都进行了数据劫持，也就是设置了 get 和 set 方法，我们在 get 方法中进行依赖的收集，在 set 方法中进行响应式数据更新的通知操作（就是通知观察者 watcher 数据发生了变化）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对属性值进行深层递归遍历</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token comment">// 为每个属性绑定一个dep</span>
    <span class="token keyword">let</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 闭包。对外暴露了 set 和 get 方法，从而使 value 值不会被回收</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token comment">// 访问属性的时候，触发get</span>
        <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment">// 全局上存在 watcher，收集这个 watcher</span>
                dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> value
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment">// 修改属性的时候，触发set</span>
        <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span>
            <span class="token comment">// 修改之后重新劫持，因为如果用户将值修改为对象，那么要对这个对象进行深度劫持</span>
            <span class="token function">observe</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span>
            value <span class="token operator">=</span> newValue
            <span class="token comment">// 修改了响应式数据之后，通知观察者更新</span>
            dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 set 方法中，我们直接调用 dep 对象的 notify 方法通知 watcher。在 get 方法中，我们需要进行判断，只有模版中的响应式数据被访问时，我们才会给这个数据对应的 dep 添加渲染 watcher 这个依赖。那么如何判断是不是模版中使用的数据触发的 get 呢？其实是通过一个全局的属性来判断的，我们在执行组件的 render 和 update 方法前，会先给 Dep 类上挂载一个全局可访问的 target 静态属性，将 当前的 watch 作为静态属性的值。执行完渲染部分的逻辑之后，再将这个全局属性的值赋为 null。</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">// 渲染函数</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在渲染开始之前，把 watcher 挂载到全局，也就是 Dep 类上（静态属性）</span>
        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 渲染结束，把全局的 watcher 卸载</span>
        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>在 get 方法中，我们对当前的全局属性 Dep.target 进行了判断，当其存在且不为 null 时，我们才会将当前的 watcher 加入到属性的 dep.subs 中。当执行 render 函数时，render 函数会向 vm 上取值，此时就触发了响应式数据的 get 方法，而此时正处于渲染流程中， Dep.target 为当前组件所对应的 watcher，所以 get 方法被触发后，会将当前的 watcher 加入到这个响应式数据所对应的 dep 的 subs 队列中。当渲染完成之后，Dep.target 被置为了 null，那么之后我们再访问响应式变量，尽管依然会触发 get 方法，但是由于 Dep.target 为 null，不会触发依赖收集的流程。所以，这样就保证了，只有模版中用到的数据，我们才会去收集对应的 watcher 依赖。</p> <h2 id="_6、梳理执行流程"><a href="#_6、梳理执行流程" class="header-anchor">#</a> 6、梳理执行流程</h2> <ol><li><p>响应式数据初始化</p> <ul><li>创建observer实例，进行defineproperty数据劫持</li> <li>在数据劫持时，为每个属性<strong>创建对应的 dep 对象</strong>，并<strong>设置 set/get方法</strong>，在 get 中进行依赖收集，set 中执行 dep.notify 也就是响应式数据变化的通知</li></ul></li> <li><p>开始准备执行组件的<strong>挂载</strong>逻辑</p> <ul><li><p>执行 <strong>new watcher</strong>，生成当前组件对应的渲染 watcher</p></li> <li><p>创建watcher实例时，会自动执行一次实例的 get 方法，也就是封装了渲染逻辑的方法，从而开始执行组件的渲染逻辑，也就是 watcher.get()</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">// watcher中封装的组件对应的渲染函数</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在渲染开始之前，把 watcher 挂载到全局，也就是 Dep 类上（静态属性）</span>
        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 渲染结束，把全局的 watcher 卸载</span>
        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
</code></pre></div></li> <li><p>渲染方法第一步，将全局的 Dep.target 的值赋为当前组件所对应的渲染 watcher</p></li> <li><p>渲染方法第二步，开始执行渲染逻辑，也就是 <code>vm._render</code>和<code>vm._update</code></p> <ul><li>执行 <code>_render</code> 方法时，render 方法中的变量会向 vm 上取值，触发属性劫持时设置的 get 方法</li> <li>get 方法中做判断，发现当前存在全局的 watcher实例，将其添加到 dep.subs 中</li></ul></li> <li><p>执行完所有的渲染逻辑之后，将全局的Dep.target的值赋为 null</p></li></ul></li> <li><p>后续我们再访问响应式数据时</p> <ul><li>触发 get 方法</li> <li>由于当前全局的 Dep.target 值为 null，不会触发依赖收集流程</li></ul></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vuepress-blog/miniVue2/5.html" class="prev">
        虚拟DOM转化为真实DOM
      </a></span> <span class="next"><a href="/vuepress-blog/miniVue2/7.html">
        $nextTick
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress-blog/assets/js/app.f8677ea4.js" defer></script><script src="/vuepress-blog/assets/js/2.32f56e5c.js" defer></script><script src="/vuepress-blog/assets/js/1.a930a345.js" defer></script><script src="/vuepress-blog/assets/js/52.1650a6e6.js" defer></script>
  </body>
</html>
