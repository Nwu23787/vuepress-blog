<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>页面加载全过程的优化策略分析 | Happyblog</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="基于 vuepress 的简易博客平台">
    
    <link rel="preload" href="/vuepress-blog/assets/css/0.styles.631b7830.css" as="style"><link rel="preload" href="/vuepress-blog/assets/js/app.f8677ea4.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/2.32f56e5c.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/1.a930a345.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/65.bb24c420.js" as="script"><link rel="prefetch" href="/vuepress-blog/assets/js/10.ab76fc9b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/11.8f72b06d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/12.428f6f98.js"><link rel="prefetch" href="/vuepress-blog/assets/js/13.eb47b2b6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/14.7257e695.js"><link rel="prefetch" href="/vuepress-blog/assets/js/15.bd1b03c3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/16.7a561afc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/17.cd516f79.js"><link rel="prefetch" href="/vuepress-blog/assets/js/18.42e9f2b1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/19.4958156f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/20.cd1f9a1c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/21.e4fea2d1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/22.0919633c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/23.331c698f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/24.5874fb5a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/25.e56a5813.js"><link rel="prefetch" href="/vuepress-blog/assets/js/26.7e912fb0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/27.aa11be6f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/28.b8505e46.js"><link rel="prefetch" href="/vuepress-blog/assets/js/29.155d9866.js"><link rel="prefetch" href="/vuepress-blog/assets/js/3.d7d8640a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/30.80297b92.js"><link rel="prefetch" href="/vuepress-blog/assets/js/31.977ccbdd.js"><link rel="prefetch" href="/vuepress-blog/assets/js/32.767609f9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/33.44891ea8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/34.f516ab0b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/35.151a5daf.js"><link rel="prefetch" href="/vuepress-blog/assets/js/36.ece446f9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/37.37735106.js"><link rel="prefetch" href="/vuepress-blog/assets/js/38.45a9e8b8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/39.0fcd7dcc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/4.ecf7f9e8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/40.621682ab.js"><link rel="prefetch" href="/vuepress-blog/assets/js/41.d03d4354.js"><link rel="prefetch" href="/vuepress-blog/assets/js/42.edf41024.js"><link rel="prefetch" href="/vuepress-blog/assets/js/43.8cd60945.js"><link rel="prefetch" href="/vuepress-blog/assets/js/44.de2cd4e9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/45.4fb41246.js"><link rel="prefetch" href="/vuepress-blog/assets/js/46.b26d762d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/47.3bb572d2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/48.dc6af168.js"><link rel="prefetch" href="/vuepress-blog/assets/js/49.9511edba.js"><link rel="prefetch" href="/vuepress-blog/assets/js/5.8cea2090.js"><link rel="prefetch" href="/vuepress-blog/assets/js/50.2e05304d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/51.f72b0b54.js"><link rel="prefetch" href="/vuepress-blog/assets/js/52.1650a6e6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/53.36c638aa.js"><link rel="prefetch" href="/vuepress-blog/assets/js/54.5931bcf4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/55.f48c6b88.js"><link rel="prefetch" href="/vuepress-blog/assets/js/56.6d799974.js"><link rel="prefetch" href="/vuepress-blog/assets/js/57.0abda071.js"><link rel="prefetch" href="/vuepress-blog/assets/js/58.e4e2e95d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/59.fc9cc726.js"><link rel="prefetch" href="/vuepress-blog/assets/js/6.5b653d91.js"><link rel="prefetch" href="/vuepress-blog/assets/js/60.d0cdc48d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/61.e663cede.js"><link rel="prefetch" href="/vuepress-blog/assets/js/62.1b3ef15b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/63.b17e2bda.js"><link rel="prefetch" href="/vuepress-blog/assets/js/64.3b7bc255.js"><link rel="prefetch" href="/vuepress-blog/assets/js/7.fcec5877.js"><link rel="prefetch" href="/vuepress-blog/assets/js/vendors~docsearch.a0f89813.js">
    <link rel="stylesheet" href="/vuepress-blog/assets/css/0.styles.631b7830.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-blog/" class="home-link router-link-active"><!----> <span class="site-name">Happyblog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vuepress-blog/miniVue2/" class="nav-link">
  mini-Vue2 文档
</a></div><div class="nav-item"><a href="/vuepress-blog/performance/" class="nav-link router-link-active">
  性能优化
</a></div><div class="nav-item"><a href="/vuepress-blog/chat/" class="nav-link">
  前端杂谈
</a></div><div class="nav-item"><a href="https://github.com/Nwu23787/mini-Vue2" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vuepress-blog/miniVue2/" class="nav-link">
  mini-Vue2 文档
</a></div><div class="nav-item"><a href="/vuepress-blog/performance/" class="nav-link router-link-active">
  性能优化
</a></div><div class="nav-item"><a href="/vuepress-blog/chat/" class="nav-link">
  前端杂谈
</a></div><div class="nav-item"><a href="https://github.com/Nwu23787/mini-Vue2" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端性能优化</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-blog/performance/前端性能优化的关键指标.html" class="sidebar-link">前端性能优化的关键指标</a></li><li><a href="/vuepress-blog/performance/页面加载全过程的优化策略分析.html" class="active sidebar-link">页面加载全过程的优化策略分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress-blog/performance/页面加载全过程的优化策略分析.html#客户端发起请求阶段" class="sidebar-link">客户端发起请求阶段</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/performance/页面加载全过程的优化策略分析.html#服务端数据处理阶段" class="sidebar-link">服务端数据处理阶段</a></li><li class="sidebar-sub-header"><a href="/vuepress-blog/performance/页面加载全过程的优化策略分析.html#页面解析和渲染阶段" class="sidebar-link">页面解析和渲染阶段</a></li></ul></li><li><a href="/vuepress-blog/performance/首屏时间指标及采集方法.html" class="sidebar-link">首屏时间指标及采集方法</a></li><li><a href="/vuepress-blog/performance/其他性能指标的采集方法.html" class="sidebar-link">其他性能指标的采集方法</a></li><li><a href="/vuepress-blog/performance/仿渐进式图片优化首屏时间.html" class="sidebar-link">仿渐进式图片优化首屏时间</a></li><li><a href="/vuepress-blog/performance/performance与performanceObserver的对比与实践.html" class="sidebar-link">performance与performanceObserver的对比与实践</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="页面加载全过程的优化策略分析"><a href="#页面加载全过程的优化策略分析" class="header-anchor">#</a> 页面加载全过程的优化策略分析</h1> <h2 id="客户端发起请求阶段"><a href="#客户端发起请求阶段" class="header-anchor">#</a> 客户端发起请求阶段</h2> <p>​		客户端请求阶段的过程主要是用户输入 URL 之后，浏览器会查找本地是否已经缓存了这个网站。如果没有，就会进行 DNS 查询获取 IP 地址，接下来进行 TCP 的三次握手和 TLS 协商向服务器发起 HTTP 请求建立连接。</p> <h3 id="本地缓存"><a href="#本地缓存" class="header-anchor">#</a> 本地缓存</h3> <p>​		本地缓存可以让静态资源加载更快，当客户端发起请求时，静态资源可以直接向客户端中获取，不需要再向服务器请求。</p> <p>​	前端本地缓存的两种方式：</p> <ul><li>强缓存：
<ul><li>浏览器在加载资源的时候，根据请求头中的 expires 和 cache-control 判断是否命中客户端缓存</li></ul></li> <li>协商缓存
<ul><li>协商缓存会先发送一个请求到服务器，服务器根据 Last-Modified 和 etag 判断是否命中缓存</li></ul></li></ul> <h3 id="dns-查询"><a href="#dns-查询" class="header-anchor">#</a> DNS 查询</h3> <p>​		每进行一次 DNS 查询，都会经过用户设备到移动信号塔，再到 DNS 认证服务器的过程。很耗费时间。</p> <p><strong>优化方式</strong>：</p> <ul><li><p>尽量减少 DNS 请求的次数</p></li> <li><p>让 DNS 查询走缓存，而不是在跳转时再进行 DNS 的查询，使用 DNS预解析（dns-prefetch）</p></li></ul> <p>dns-prefetch ：</p> <ul><li><a href="https://blog.csdn.net/langyu1021/article/details/78923009?ops_request_misc=%7B%22request%5Fid%22%3A%22171230234016800225532685%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171230234016800225532685&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-78923009-null-null.142%5Ev100%5Epc_search_result_base7&amp;utm_term=DNS%E9%A2%84%E8%8E%B7%E5%8F%96&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener noreferrer">前端优化系列:DNS预获取 dns-prefetch 提升页面载入速度_dns prefecth-CSDN博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/zz130428/article/details/128488194?ops_request_misc=%7B%22request%5Fid%22%3A%22171230234016800225532685%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171230234016800225532685&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-128488194-null-null.142%5Ev100%5Epc_search_result_base7&amp;utm_term=DNS%E9%A2%84%E8%8E%B7%E5%8F%96&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener noreferrer">DNS 预解析是什么？怎么实现？_dns预解析-CSDN博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="http-请求"><a href="#http-请求" class="header-anchor">#</a> HTTP 请求</h3> <p>​		HTTP 请求的瓶颈在于<strong>请求阻塞</strong>，因为浏览器为了保证访问速度，默认对同一域名的请求是有最大连接数的限制的，一般最多只能并发6个，请求过多就会导致阻塞。</p> <p>​		一些主流浏览器对 HTTP 1.1 和 HTTP 1.0 的最大并发连接数目</p> <table><thead><tr><th>Browser</th> <th>HTTP/1.1</th> <th>HTTP/1.0</th></tr></thead> <tbody><tr><td>IE 11</td> <td>6</td> <td>6</td></tr> <tr><td>IE 10</td> <td>6</td> <td>6</td></tr> <tr><td>IE 9</td> <td>10</td> <td>10</td></tr> <tr><td>IE 8</td> <td>6</td> <td>6</td></tr> <tr><td>IE 6,7</td> <td>2</td> <td>4</td></tr> <tr><td>Firefox</td> <td>6</td> <td>6</td></tr> <tr><td>Safari 3,4</td> <td>4</td> <td>4</td></tr> <tr><td>Chrome 4+</td> <td>6</td> <td>6</td></tr> <tr><td>Opera 10.51+</td> <td>8</td> <td>?</td></tr></tbody></table> <p><strong>优化方式</strong>：</p> <ul><li><strong>域名规划</strong>：
尤其是对于首屏来说，看看页面中需要用到哪些域名，对这些域名的请求顺序进行规划</li> <li><strong>域名散列</strong>：
将静态资源请求的域名<strong>散列到不同的域名上</strong>，这样可以增加并行请求的连接数。比如我们想要同时向 <code>www.google.com</code> 发起10个请求，获取相应的静态资源。而当前浏览器限制同一域名下并发的最大连接数是6。此时我们就要进行域名的散列，将原先的 <code>www.google.com</code> 散列为 <code>www.google0.com</code>、 <code>www.google1.com</code>、 <code>www.google2.com</code>或者更多，每次请求时随机选取一个域名进行请求，这样最多就可以同时并发18个HTTP连接了。</li></ul> <h2 id="服务端数据处理阶段"><a href="#服务端数据处理阶段" class="header-anchor">#</a> 服务端数据处理阶段</h2> <p>​		服务端数据处理阶段是指服务器收到请求之后，从数据存储层取到数据，再返回给前端的过程。每请求一次数据，都需要从客户端到服务器，在到更后端的数据存储层，然后再一层一层的返回到前端，耗时很长。</p> <h3 id="gzip"><a href="#gzip" class="header-anchor">#</a> Gzip</h3> <p>​		Gzip 是一种压缩技术，服务端通过 Gzip 压缩，传输到客户端的资源的大小可以变为原来的三分之一左右，可以极大程度的优化资源的下载时间，大大的提高页面的展示速度。一般来说，运维团队会默认开启 Gzip 压缩，不需要前端处理。</p> <h3 id="数据缓存"><a href="#数据缓存" class="header-anchor">#</a> 数据缓存</h3> <h4 id="借助-service-worker-进行数据接口缓存"><a href="#借助-service-worker-进行数据接口缓存" class="header-anchor">#</a> 借助 Service Worker 进行数据接口缓存</h4> <p>​		service worker 是浏览器的一个高级属性，本质上是一个请求代理层，它存在的目的就是拦截和处理网络数据请求</p> <ul><li><a href="https://blog.csdn.net/aini423/article/details/105681488" target="_blank" rel="noopener noreferrer">前端缓存——Service Worker（重点介绍）_service worker 缓存<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h4 id="借助本地存储的接口缓存"><a href="#借助本地存储的接口缓存" class="header-anchor">#</a> 借助本地存储的接口缓存</h4> <p>​		对于一些<strong>数据时效性要求不高</strong>的数据，在第一次请求到数据之后，将数据存储在本地存储当中，下一次请求的时候，先去缓存中获取资源，如果没有的话，再向服务器发起请求。</p> <h4 id="cdn"><a href="#cdn" class="header-anchor">#</a> CDN</h4> <p>​		Content Delivery Network，中文叫内容分发网络。通过在现有的Internet中增加一层新的CACHE(缓存)层，将将用户的请求导向离用户最近的服务节点上，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。</p> <h3 id="重定向"><a href="#重定向" class="header-anchor">#</a> 重定向</h3> <p>重定向是指网站的资源迁移到其他位置之后，用户访问站点时，程序自动将用户的请求从一个页面转移到另一个页面的过程。这个过程中会引发新的 DNS 查询、TCP 三次握手以及 TLS 协商，并且产生新的 HTTP 请求。非常耗费时间。</p> <h2 id="页面解析和渲染阶段"><a href="#页面解析和渲染阶段" class="header-anchor">#</a> 页面解析和渲染阶段</h2> <p><strong>解析</strong>：HTML 解析器把页面内容转换为 DOM 树和 CSSOM 树的过程</p> <p><strong>DOM 树</strong>：全称 Document Object Model ，即文档对象模型，描述了各个标签之间的层次结构</p> <p><strong>CSSOM 树</strong>：即 <strong>CSS 对象模型</strong>，主要描述样式集的层次和结构。CSS 解析器遍历每个 CSS 样式规则，将 CSS 规则解析成浏览器可以解析和处理的样式集合，最终结合浏览器中的默认样式，汇总形成具有父子关系的 CSSOM 树。</p> <p><strong>渲染</strong>：主线程会计算 DOM 节点的最终样式，生成布局树，布局树会记录参与页面布局的节点和样式</p> <p><strong>绘制</strong>：把各个节点绘制到屏幕上的过程。结果以层的方式保存。当文档中各个部分以不同的层绘制时，相互重叠时，就必须进行合成。</p> <h3 id="构建-dom-树的优化"><a href="#构建-dom-树的优化" class="header-anchor">#</a> 构建 DOM 树的优化</h3> <ul><li><strong>规范 HTML 语法</strong>。当 HTML 语法有小的错误时（比如<code>&lt;br&gt;</code>标签少写了结束符号之类的），浏览器会进行语法纠错，这样就导致页面的解析时间变长，影响页面性能。</li> <li><strong>尽量精简 DOM 的数量</strong>。因为 DOM 节点数量越多，构建 DOM 树的时间就越长，进而导致页面的解析时间变长，影响页面性能。</li> <li><strong>延迟加载或使用 defer 和 async 优化 script 标签的资源请求</strong>。无论是 DOM 还是 CSSOM ，都可以被 JS 所修改，所以，一旦页面在解析的时候遇到了 <code>&lt;script&gt;</code> 标签，<strong>DOM 的解析构建就会被暂停</strong>，等待服务器下载并执行脚本资源之后，才会继续解析 DOM。因此，外部<code>&lt;script&gt;</code> 标签经常被称为解析阶段的拦路虎，有时就因为解析过程中多了一个外部script标签，页面的解析阶段就由 200ms 变成了1s。所以，外部脚本的加载时机非常重要，能够延迟加载就延迟加载，或者通过使用 defer 和 async 告诉浏览器，在等待脚本下载的期间，不暂停 HTML 解析。</li></ul> <h3 id="布局阶段的优化"><a href="#布局阶段的优化" class="header-anchor">#</a> 布局阶段的优化</h3> <p>​	布局阶段，浏览器根据CSS解析器给出的样式规则，来计算某个元素需要占据的空间的大小和在页面中的位置，借助计算的结果来进行布局。</p> <ul><li><p><strong>尽量不要在渲染阶段改变元素样式</strong>：主线程采用的是<strong>流模型</strong>的布局方式，即从上到下、从左到右进行遍历所有的元素进行布局。如果我们在渲染阶段改变了一个元素的布局属性，那么此时浏览器必须检查所有其他的元素，然后自动重排页面，受到影响的元素需要重新绘制，相当于重新进行了一次渲染过程。</p></li> <li><p><strong>尽量精简 DOM 数量</strong>：因为浏览器每次布局都需要作用于整个 DOM 对象，如果节点数量多，计算所有的元素位置和尺寸会耗费很长时间。</p></li></ul> <p>​		上述第一点很重要，我在做博客列表页项目时，一开始布局的时候，没有给定列表封面图片的初始大小，这样会导致只有当图片加载完成之后，主线程才知道了图片的大小，不得不重新进行布局计算，然后再次进行页面渲染（重绘 + 重排），导致页面加载时间过长。所以后面采取了给定封面图片大小的方式，避免了这些浏览器的重复布局。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vuepress-blog/performance/前端性能优化的关键指标.html" class="prev">
        前端性能优化的关键指标
      </a></span> <span class="next"><a href="/vuepress-blog/performance/首屏时间指标及采集方法.html">
        首屏时间指标及采集方法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress-blog/assets/js/app.f8677ea4.js" defer></script><script src="/vuepress-blog/assets/js/2.32f56e5c.js" defer></script><script src="/vuepress-blog/assets/js/1.a930a345.js" defer></script><script src="/vuepress-blog/assets/js/65.bb24c420.js" defer></script>
  </body>
</html>
