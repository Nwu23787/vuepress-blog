(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{298:function(t,a,s){t.exports=s.p+"assets/img/Snipaste_2024-07-18_17-25-44.9ad4dafd.png"},299:function(t,a,s){t.exports=s.p+"assets/img/Snipaste_2024-07-18_17-54-59.e8e5ed10.png"},300:function(t,a,s){t.exports=s.p+"assets/img/Snipaste_2024-07-18_18-09-45.3b0baf4d.png"},373:function(t,a,s){"use strict";s.r(a);var e=s(14),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"requestanimationframe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#requestanimationframe"}},[t._v("#")]),t._v(" requestAnimationFrame")]),t._v(" "),a("h2",{attrs:{id:"requestanimationframe-是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#requestanimationframe-是什么"}},[t._v("#")]),t._v(" requestAnimationFrame 是什么")]),t._v(" "),a("p",[t._v("requestAnimationFrame 是 H5 新增的一个 API，目的是用于解决定时器不准的问题。requestAnimationFrame 接收一个回调函数，并会在浏览器下一帧渲染之前调用这个回调函数。")]),t._v(" "),a("h2",{attrs:{id:"setinterval-准确吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setinterval-准确吗"}},[t._v("#")]),t._v(" setInterval 准确吗")]),t._v(" "),a("p",[t._v("答案是不准确的。推荐阅读官方文档：原因如下："),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/setInterval",target:"_blank",rel:"noopener noreferrer"}},[t._v("setInterval() - Web API | MDN (mozilla.org)"),a("OutboundLink")],1)]),t._v(" "),a("ol",[a("li",[t._v("当 setInterval 嵌套层级超过 5 层时，小于 4 毫秒的定时器设定将会被强制固定为 4 毫秒\n"),a("img",{attrs:{src:s(298),alt:""}})]),t._v(" "),a("li",[t._v("由于 JS 的"),a("strong",[t._v("单线程")]),t._v("设定，setInterval 根本不在乎主线程是否空闲，只要设定的时间到达，他就会将回调加入到任务队列中，至于 JS 主线程是否空闲、是否能及时执行该任务，无法保证。所以，回调的执行时间不一定是准确的。")]),t._v(" "),a("li",[t._v("当 setInterval 的"),a("strong",[t._v("回调执行时间大于我们设置的时间间隔")]),t._v("时，真实的时间间隔一定是大于我们设置的时间的。因为除了第一次外，后面每一次向任务队列添加回调函数时，JS 主线程一定不是空闲的，至少还在执行上一次 setInterval 添加的回调任务。因此，如果我们回调任务的时间可能大于我们设定的时间间隔，推荐使用 settimeout 循环的方式。\n"),a("img",{attrs:{src:s(299),alt:""}}),t._v("\n采用这种方式，虽然也不能保证时间间隔准确，但是"),a("strong",[t._v("可以保证在下一个回调开始时，上一个回调一定已经完成")]),t._v("。")])]),t._v(" "),a("h2",{attrs:{id:"settimeout-准确吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#settimeout-准确吗"}},[t._v("#")]),t._v(" setTimeout 准确吗")]),t._v(" "),a("p",[t._v("虽然在某些情况下，我们推荐使用循环 settimeout 的方式来模拟实现 setInterval，但这并不代表 settimeout 就是准确的。实际上，settimeout 同样不准确，原因和 setInterval 类似。"),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout",target:"_blank",rel:"noopener noreferrer"}},[t._v("setTimeout() 全局函数 - Web API | MDN (mozilla.org)"),a("OutboundLink")],1)]),t._v(" "),a("ol",[a("li",[a("p",[t._v("当 settimeout嵌套层级超过 5 层时，小于 4 毫秒的定时器设定将会被强制固定为 "),a("strong",[t._v("4 毫秒")]),t._v(" "),a("img",{attrs:{src:s(300),alt:""}})])]),t._v(" "),a("li",[a("p",[t._v("为了减少损耗，对于"),a("strong",[t._v("不活动的浏览器标签页")]),t._v("（非当前展示的标签页），浏览器会对 settimeout "),a("strong",[t._v("强制设置一个最小的超时值")]),t._v("，甚至可能直接取消 settimeout。\n这方面的具体情况与浏览器有关：")]),t._v(" "),a("ul",[a("li",[t._v("Firefox 桌面版和 Chrome 针对不活动标签都有一个 1 秒的最小超时值。")]),t._v(" "),a("li",[t._v("安卓版 Firefox 浏览器对不活动的标签有一个至少 15 分钟的超时，"),a("strong",[t._v("并可能完全卸载它们")]),t._v("。")])])]),t._v(" "),a("li",[a("p",[t._v("由于 JS 的"),a("strong",[t._v("单线程")]),t._v("设定，settimeout 根本不在乎主线程是否空闲，只要设定的时间到达，他就会将回调加入到任务队列中，至于 JS 主线程是否空闲、是否能及时执行该任务，无法保证。所以，回调的执行时间不一定是准确的。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("超时时间有最大值")]),t._v("。浏览器内部以 32 位带符号整数存储延时。这就会导致如果一个延时大于 2147483647 毫秒（大约 24.8 天）时就会溢出，导致定时器将会被立即执行。这是少见的提前执行的例子")])])]),t._v(" "),a("h2",{attrs:{id:"requestanimationframe-准确吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#requestanimationframe-准确吗"}},[t._v("#")]),t._v(" requestAnimationFrame 准确吗")]),t._v(" "),a("p",[t._v("从时间上来看， requestAnimationFrame 未必准确，它的执行时间和时间并无直接关联，而是在浏览器重新渲染页面前执行，所以我们无法设定它在某个时间点执行（尽管大多数浏览器的刷新频率为 60 HZ，但浏览器的实时刷新频率是无法保证的）。但是它可以保证回调一定是在下一次浏览器重新渲染页面时执行，所以也可以说 requestAnimationFrame 是准确的。")]),t._v(" "),a("h2",{attrs:{id:"requestanimationframe-的简单用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#requestanimationframe-的简单用法"}},[t._v("#")]),t._v(" requestAnimationFrame 的简单用法")]),t._v(" "),a("p",[t._v("requestAnimationFrame 的用法和 settimeout 类似，但是 requestAnimationFrame 无法设置超时时间。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" timer "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("requestAnimationFrame")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 123")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("取消 requestAnimationFrame ：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("cancelAnimationFrame")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("timer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h2",{attrs:{id:"兼容性处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#兼容性处理"}},[t._v("#")]),t._v(" 兼容性处理")]),t._v(" "),a("p",[t._v("由于 requestAnimationFrame 是 H5 的一个新 API，所以在兼容性方面，可能并不是所有浏览器都实现了这个 API。所以，我们在使用的时候可以对 requestAnimationFrame 的兼容性做一个简单的处理。")]),t._v(" "),a("p",[t._v("一般浏览器的刷新频率为 60HZ，所以，在每一帧的刷新间隔为 1000/60 ，约等于 17ms。所以，如果浏览器不支持 requestAnimationFrame API，那么我们"),a("strong",[t._v("可以使用 settimeout 来模拟 requestAnimationFrame")]),t._v("，设置超时时间为 17ms即可。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("window"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("requestAnimationFrame"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("requestAnimationFrame")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("fn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("17")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);