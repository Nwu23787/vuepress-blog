(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{343:function(t,a,s){t.exports=s.p+"assets/img/ashj.977fda10.jpg"},394:function(t,a,s){"use strict";s.r(a);var n=s(14),e=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue2-异步更新原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2-异步更新原理"}},[t._v("#")]),t._v(" Vue2 异步更新原理")]),t._v(" "),a("p",[t._v("前面讲解了 Vue2 的依赖收集和视图同步更新原理，当响应式数据发生变化之后， 就会让属性对应的 dep 实例去通知对应的 watcher，对应的 watcher 执行更新方法，立即更新相应的组件。但是这会导致一个非常严重的性能问题，那就是我们每次修改响应式数据，都会发生一次组件的重新渲染。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),t._v("\na "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("800")]),t._v("\na "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n")])])]),a("p",[t._v("在这一组代码中，a 变化了三次，那么视图就更新了三次。我们知道 Vue 的视图更新是以组件为粒度的，a 数据发生变化，那么就会导致所有与 a 相关的组件都要重新渲染一次，而此处 a 变化了三次，那么所有与 a 相关的组件都要重新渲染三次，非常浪费性能。其实我们最后希望看到的视图中的 a 只是 0 而已。中间的 1000 和 800，我们的视图并不关心。所以我们需要一种方式，来将所有的更新延迟到当前同步代码执行完毕之后。")]),t._v(" "),a("h2",{attrs:{id:"_1、批处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、批处理"}},[t._v("#")]),t._v(" 1、批处理")]),t._v(" "),a("p",[t._v("批处理是 Vue 中很常见的一个策略，他的原理就是将多次任务收集起来，统一进行处理。在实现异步更新时，我们也希望将多次数据变化导致 watcher 执行更新的这个操作收集起来，集中在一次全部更新完。那么首先我们就要收集更新操作，而这个更新操作存在于每一个 watcher 上，那么我们只需要收集执行更新方法的 watcher 即可。")]),t._v(" "),a("h2",{attrs:{id:"_2、实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、实现原理"}},[t._v("#")]),t._v(" 2、实现原理")]),t._v(" "),a("p",[t._v("首先，响应式数据发生变化，dep 实例会通知所有的 watcher 去执行 update 方法。对于渲染 watcher，他的 update 方法是：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 更新视图")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("update")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 把当前的 watcher 暂存在队列中")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("queueWatcher")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// this.get()")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("只是调用了 queueWatcher 方法，将需要执行更新操作的 watcher 缓存在调度队列中")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 缓存 watcher 队列")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" queue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 去重的辅助对象，源码中没用 set，用的是对象")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" has "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 防抖")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" pending "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 刷新 watcher 队列")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("flushSchedulerQueue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 拷贝一份queue，如果在更新的过程中产生了新的 watcher，会加入到 queue 队列中，下一次清空队列时才执行，不会在这一次执行")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" flushQueue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" queue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("slice")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    queue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    has "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    pending "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n    flushQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("item")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("run")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("queueWatcher")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("watcher")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 通过判断watcher的id进行去重，避免同一个组件多次刷新")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" watcher"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("has"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 没有重复")]),t._v("\n        queue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("watcher"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        has"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在第一次加入 watcher 之后，就会将刷新队列的任务加入")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("pending"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("nextTick")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("flushSchedulerQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            pending "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("从源码中可以看到，如果是第一次向空队列中加入 watcher，那么会调用 nextTick 函数，并将刷新调度队列的方法 flushSchedulerQueue 作为回调传入 nextTick。我们在上一章说到，nextTick 会将传入的回调加入到 nextTick 的调度队列中，在当前同步代码完成之后，会执行刷新 nextTick 的调度队列的方法，来顺序执行 nextTick 调度队列中的每一个回调。所以，我们将 flushSchedulerQueue 传入 nextTick，其实就是将其延迟到同步代码全部执行完成之后再执行，也就是只有当前所有的同步代码执行完成之后，我们才会去刷新 watcher 队列，执行每一个 watcher 的 DOM 更新方法。")]),t._v(" "),a("p",[t._v("如果还拿上面那个例子来说，a 变化了三次，但这三次都是在同步代码中发生的变化，那么 a 对于的 watcher.update 就执行的三次，而 update 方法其实就是向当前的 watcher 队列中加入 watcher。a 第一次变化时，watcher 队列中没有 a 对应的 watcher，那么就会将 a 对应的 watcher 加入队列。之后 a 发生的两次变化，同样会触发 watcher.update 方法，但此时 a 对应的 watcher 已经在 watcher 队列中了，不会再重复添加（这里判重用的是对象，而不是 set）")]),t._v(" "),a("h2",{attrs:{id:"_3、实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、实例"}},[t._v("#")]),t._v(" 3、实例")]),t._v(" "),a("h3",{attrs:{id:"实例1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例1"}},[t._v("#")]),t._v(" 实例1：")]),t._v(" "),a("p",[t._v("对于这样一段代码，我们来分析他的底层执行过程：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// name 初始值18  age 初始值 34")]),t._v("\n\tvm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v("\n    vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n    vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("$nextTick")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("age"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//100")]),t._v("\n      console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("app"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("innerHTML"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可以拿到更新之后 age 等于100的DOM")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v("\n")])])]),a("p",[a("img",{attrs:{src:s(343),alt:"绘图1"}})]),t._v(" "),a("p",[t._v("可以发现，即使 vm.age = 100 是在 nextTick 之后做的，但是 nextTick 的回调还是"),a("strong",[t._v("能拿到最新的 age 值对应的 DOM")]),t._v("。这是因为在nextTick 前面，我们对 name 的值做了修改，那么就导致刷新 watcher 队列的函数进入了 nextTick 的调度队列中；而后我们又执行了 nextTick 方法，将其中传入的回调加入 nextTick 的调度队列中，在刷新 watcher 队列的方法之后。所以，更新所有 Watcher 的方法会在  "),a("code",[t._v("console.log(app.innerHTML)")]),t._v(" 之前执行，这样即使我们对 age 的修改在 nextTick 之后，我们依然能在 nextTick 的回调中拿到 age 等于 100 的 DOM。")]),t._v(" "),a("h3",{attrs:{id:"实例2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实例2"}},[t._v("#")]),t._v(" 实例2：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// age 初始值 34")]),t._v("\n\tvm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("$nextTick")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("age"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("app"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("innerHTML"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// age=34")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tvm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v("\n")])])]),a("p",[t._v("这题中，我们只能拿到 age 为初始值的 DOM，这就意味着，nextTick 中获取 DOM 的操作执行在了更新 DOM 操作之前。我们来分析一下，这题和上一题的最大区别就是，上一题在nextTick之前，修改了 name 的值。"),a("strong",[t._v("可是修改 name 的值，为什么会对 age 的更新有影响呢？")])]),t._v(" "),a("p",[t._v("首先，Vue 的异步更新原理中，"),a("strong",[t._v("只有第一次修改响应式数据时，才会将刷新 watcher 队列的方法加入 nextTick 的调度队列中")]),t._v("。对于第一题，我们在 vm.$nextTick 前修改了 name 的值，那么就会将刷新 watcher 队列的方法加入 nextTick 的调度队列，后续我们再执行"),a("code",[t._v("vm.$nextTick")]),t._v("时，传入的回调就放在了刷新 watcher 队列的方法的后面，那么我们就可以获取到最新的 DOM 了。")]),t._v(" "),a("p",[t._v("对于第二题，由于"),a("code",[t._v("vm.$nextTick")]),t._v("之前没有进行任何变量的修改，那么在执行"),a("code",[t._v("vm.$nextTick")]),t._v("的时候，传入的回调就排在了 nextTick 调度队列的首位。后续修改 age 的值，导致刷新 watcher 的队列加入 nextTick，此时会排在我们第一次调用nextTick传入的回调"),a("strong",[t._v("之后")]),t._v("。也就是说，我们会先执行log，再更新 DOM。自然就获取不到 age 变化后的 DOM 了。")]),t._v(" "),a("p",[t._v("这两题非常的好，对于理解异步更新和 nextTick 的原理大有裨益！")]),t._v(" "),a("p",[t._v("本文共 1730 字（含代码），截止本篇，本系列累计 17963 字")])])}),[],!1,null,null,null);a.default=e.exports}}]);