(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{371:function(r,e,v){"use strict";v.r(e);var _=v(14),o=Object(_.a)({},(function(){var r=this,e=r._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"web-worker简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#web-worker简介"}},[r._v("#")]),r._v(" Web Worker简介")]),r._v(" "),e("h2",{attrs:{id:"单线程的-javascript"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单线程的-javascript"}},[r._v("#")]),r._v(" 单线程的 JavaScript")]),r._v(" "),e("p",[r._v("JavaScript 是作为浏览器脚本语言而设计的，主要用于与用户交互、操作 DOM，所以在诞生之初，就被设计为了"),e("strong",[r._v("单线程语言")]),r._v("。")]),r._v(" "),e("p",[r._v("最初的 JavaScript 主要是用于操作页面上的 DOM，如果设计为了多线程语言，那么同时可能有多处地方在执行 JS 代码修改 DOM。一旦这些代码修改了同一处 DOM，那么就会导致冲突。")]),r._v(" "),e("p",[r._v("此外，"),e("strong",[r._v("浏览器的 JS 引擎是与 UI 渲染线程互斥")]),r._v("的。当 JS 引擎执行任务时，UI 渲染引擎会被挂起。这是因为 UI 渲染引擎执行的过程中，如果执行 JS 代码，那么可能会导致 DOM 元素被修改，从而进一步导致渲染结果和预期不一致。")]),r._v(" "),e("p",[r._v("单线程语言虽然较为安全，避免了多线程竞争条件下的各种问题，但也导致了一系列问题：")]),r._v(" "),e("ol",[e("li",[e("strong",[r._v("性能瓶颈")]),r._v("：单线程语言意味着 JavaScript 在同一时间只能执行一个任务，这在需要大量计算或者并发任务的场景中，就显得非常低效了")]),r._v(" "),e("li",[e("strong",[r._v("阻塞任务")]),r._v("：一旦有一个任务被阻塞，或是处理时间较长，那么所以其他的任务都会被阻塞，得不到有效的处理")]),r._v(" "),e("li",[e("strong",[r._v("无法充分利用多核 CPU 的性能")]),r._v("：现代计算机通常有多个 CPU 核心，单线程无法充分利用这些资源，从而导致资源浪费。")])]),r._v(" "),e("p",[r._v("为了提高 web 应用的响应速度和用户体验，于是我们引入了 Web Worker 的概念")]),r._v(" "),e("h2",{attrs:{id:"什么是-web-worker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-web-worker"}},[r._v("#")]),r._v(" 什么是 Web Worker")]),r._v(" "),e("blockquote",[e("p",[e("strong",[r._v("Web Worker")]),r._v(" 使得在一个独立于 Web 应用程序主执行线程的后台线程中运行脚本操作成为可能。这样做的好处是可以在独立线程中执行费时的处理任务，使主线程（通常是 UI 线程）的运行不会被阻塞/放慢")]),r._v(" "),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API",target:"_blank",rel:"noopener noreferrer"}},[r._v("Web Worker API - Web API | MDN (mozilla.org)"),e("OutboundLink")],1)])]),r._v(" "),e("p",[r._v("Web Worker 是浏览器的"),e("strong",[r._v("内置线程")]),r._v("，允许开发者在浏览器后台运行 JavaScript 代码。创建 Web Worker 时，js 引擎向浏览器申请一个子线程， 子线程完全由浏览器控制，它"),e("strong",[r._v("完全独立于主线程")]),r._v("，用于自己独立的内存和全局变量，所以可以与主线程并行执行，互不干扰。")]),r._v(" "),e("p",[r._v("但是，正如我们前面提到的：我们不希望同时有两处代码在修改 DOM。所以，Web Worker 中是无法直接访问到 DOM 的，请勿将操作 DOM 相关的代码交由 Web Worker 执行。Web Worker 更适合去执行一些耗时的复杂任务，如大量计算等。")]),r._v(" "),e("h2",{attrs:{id:"web-worker-的类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#web-worker-的类型"}},[r._v("#")]),r._v(" Web Worker 的类型")]),r._v(" "),e("p",[e("strong",[r._v("Dedicated Worker")]),r._v("：专用 Worker。该 Worker "),e("strong",[r._v("只能")]),r._v("被创建它的脚本使用")]),r._v(" "),e("p",[e("strong",[r._v("Shared Worker")]),r._v("：共享 Worker。可以同时被多个标签页使用，但是这些标签页必须"),e("strong",[r._v("同源")]),r._v("。")]),r._v(" "),e("p",[e("strong",[r._v("Service Worker")]),r._v("：服务 Worker。几乎都是用于充当浏览器与服务器之间的"),e("strong",[r._v("代理服务器")]),r._v("，实现请求的拦截。在"),e("strong",[r._v("离线场景")]),r._v("中得到了广泛的运用。")]),r._v(" "),e("h2",{attrs:{id:"与主线程的通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与主线程的通信"}},[r._v("#")]),r._v(" 与主线程的通信")]),r._v(" "),e("p",[r._v("主线程和Worker线程之间通过"),e("code",[r._v("postMessage")]),r._v("和"),e("code",[r._v("onmessage")]),r._v("事件进行通信。主线程可以向Worker发送消息，Worker处理后再将结果返回给主线程。")]),r._v(" "),e("p",[r._v("Shared Worker 与其他 Worker 的通信方式略有差别，需要通过活动端口 "),e("code",[r._v("port")]),r._v(" 进行通信。以下是具体步骤：")]),r._v(" "),e("ol",[e("li",[e("strong",[r._v("创建Shared Worker")]),r._v("：在主线程中创建Shared Worker实例。")]),r._v(" "),e("li",[e("strong",[r._v("获取MessagePort")]),r._v("：通过"),e("code",[r._v("SharedWorker.port")]),r._v("属性获取"),e("code",[r._v("MessagePort")]),r._v("对象。")]),r._v(" "),e("li",[e("strong",[r._v("启动端口")]),r._v("：使用"),e("code",[r._v("port.start()")]),r._v("方法启动端口（如果使用"),e("code",[r._v("addEventListener")]),r._v("监听消息）。")]),r._v(" "),e("li",[e("strong",[r._v("发送消息")]),r._v("：使用"),e("code",[r._v("port.postMessage()")]),r._v("方法发送消息。")]),r._v(" "),e("li",[e("strong",[r._v("接收消息")]),r._v("：通过"),e("code",[r._v("port.onmessage")]),r._v("事件处理接收到的消息。")])]),r._v(" "),e("h2",{attrs:{id:"安全与限制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安全与限制"}},[r._v("#")]),r._v(" 安全与限制")]),r._v(" "),e("ol",[e("li",[e("strong",[r._v("同源")]),r._v("：Web Worker 必须和调用它的页面同源，以确保安全，防止跨站脚本攻击")]),r._v(" "),e("li",[e("strong",[r._v("不可访问 DOM")]),r._v("：Worker线程无法直接访问DOM。不能在Worker中直接操作页面元素，但可以通过消息传递与主线程协作。")]),r._v(" "),e("li",[e("strong",[r._v("浏览器API受限")]),r._v("：Worker线程中不能使用某些浏览器API，如"),e("code",[r._v("alert")]),r._v("、"),e("code",[r._v("confirm")]),r._v("和"),e("code",[r._v("localStorage")]),r._v("。")])]),r._v(" "),e("h2",{attrs:{id:"应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[r._v("#")]),r._v(" 应用场景")]),r._v(" "),e("ol",[e("li",[e("strong",[r._v("跨标签页通信")]),r._v("：使用 Shared Worker 或 Service Worker 可以实现跨标签页的消息传递，详情可参考："),e("a",{attrs:{href:"https://nwu23787.github.io/vuepress-blog/chat/%E8%B7%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%A1%88%E4%B8%8E%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%8A%EF%BC%89.html#service-worker-onmessage",target:"_blank",rel:"noopener noreferrer"}},[r._v("跨标签页通信的方案与实践（上） | Happyblog"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("strong",[r._v("大量数据计算")]),r._v("：对于大量数据的计算，在主线程中进行会导致页面卡顿，后续任务被阻塞。此时可以考虑使用 Web Worker 进行计算，主线程继续执行后续任务。待 Web Worker 执行完毕之后，再使用 "),e("code",[r._v("postMessage")]),r._v(" 通知主线程。")]),r._v(" "),e("li",[e("strong",[r._v("网络请求")]),r._v(" ：对于某些耗时较长的网络请求，可以在 Web Worker 中进行，避免阻塞主线程。")]),r._v(" "),e("li",[e("strong",[r._v("接口缓存")]),r._v("：对于数据量较大，且数据变化不频繁的接口，可以使用 Service Worker 进行接口缓存。拦截网络请求，不发送给服务器。")]),r._v(" "),e("li",[e("strong",[r._v("离线缓存")]),r._v("：对于类似聊天类软件，在离线时依然要展示聊天记录之类的大量数据，可以考虑使用 Service Worker 配合 IndexDB 进行。")])])])}),[],!1,null,null,null);e.default=o.exports}}]);